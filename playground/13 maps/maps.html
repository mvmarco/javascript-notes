<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Maps</title>
  <link rel="stylesheet" href="../../base.css">
</head>

<body>
  <ul class="prizes"></ul>
  <script>
  /* 
    similar to an object. Here we learn: 
    1 how does it work
    2 what does it do 
    3 why you wanna use it instead of an object, when map or object
  */

// ##############################
// KEY DIFFERENCES FOR INTERVIEWS
// ##############################

/* with map() 

    1 key and values can be any types

    2 the order of how you put the things is the order of how they are presented. In other words
    each object order matters, that is why you can call the index. 
    for instance if you gotta loop over a map the order matters, when you get what you need stops
    if you loop an object it can stop even before the right result
    (IF YOU WANNA MAINTAIN THE ORDER OF THE ITEMS MAP IS THE CHOICE)

    3 with Map() there is not literal, aka we need to create a new Map() and then .set() items in it
    however you can also create it with an array of an array like: 
    new Map([['name', 'marco']['age', 29]]); - first element key and second value

    4 you can put functions inside of an object we call them methods, with maps you can.
    they are just used to store data.

    5 JSON: if we have an object or an array and we have to send/transfer it to someone/server 
    we need to convert it to text because it is easier. and we do it with JSON.stringify(person)
    in case we have const person = {name: 'marco', age: 1000} and you can even email the
    string to someone and they can convert it back to an object with 
    JSON.parse("{name: 'marco', age: 1000}") - json stands for JavaScript Object Notation,
    every language uses it though. JSON does not handle maps.  All the methods will get error
    or get back an empy object. So if you have a map and you want to send it to someone you gotta
    convert it to an object. with: Object.fromEntries(myMap) but if you use an object as a key
    the convertion is gonna create problems

*/

  const myMap = new Map();

  // in order to build or to add items to a map we have: .set(); .has() .delete();

// ############################
// .set()
// ############################
  
  // .set(); set key and value, first key and second the value
  myMap.set('name', 'wes');

  // if you do:
  myMap.age = 100;
  console.log(myMap);

  /*  
    By the way: in the console if you call myMap you get myMap(1) because there is only one set of
    key value so far
  
   
    age = 100 will be not added to the set key value such as on line 29 (entries)
    but it will be just a property of the map. if you do myMap.age = 100 
    you just add the property age: 100 and not an object so there is no way of calling it
    as you would with an index but instead with entries.age
  */

  /* 
   with set() you can set any type or format as a key or value. Numbers, variables, or even arrays or boolean

   This would be useful when using dictionaries
  
    dictionaries is a way to store additional metadata (data that describes other data) 
    to something else, check the example below of person1 the dictionary, with object the word
  */
  const person1 = {
    name: 'wes',
    age: 200,
  };

  // numbers
  myMap.set(100, 'This is a number');
  // or variables or objects
  myMap.set(person1, 'Really Cool');
  console.log(myMap);

  // to get some values from myMap you do:
  console.log(myMap.get(person1));

  // so another example:

  const score = 300; // so if you change this you get different prizes in line 77
  const prizes = new Map();
  prizes.set(100, 'bear');
  prizes.set(200, 'duck');
  prizes.set(300, 'car');
  console.log(prizes.get(score));

  /* 
    another thing is that the order of how you put the data is the order of how they are presented.
    In other words
    each object order matters, that is why you can call the index 

    for instance if you gotta loop over a map the order matters, when you get what you need 
    (eg. 1 2 3 4) stops. imagining to adding to something a value until the 4th result.
    it includes everything before 4.
    if you loop an object it can stop even before the right result because there is no order
    (eg. 2 4 1 3) stops.
    it includes only 2.
  */

  const ul = document.querySelector('.prizes');

  prizes.forEach((prize) => {
    console.log(prize);
  });

  /* 
    since we call prize just the first value of the forEach we get the values
    prizes.forEach((value, key) => {
    console.log(key, value);;
    });  

    with forEach iterate a Map object getting its elements in insertion order â€” 
    with a for...of loop returns an array of [key, value] for each iteration
    so we can do also:
  */

  for (const prize of prizes) {
    console.log(prize); // we get the arrays [100, 'bear'],[200, 'duck'],[300, 'car']
    // so we can also call the indexes and get the individual values:
    console.log(prize[0], prize[1]);
  }

  /* 
    we can also destructuring: taking the array and instead of referencing value by their own 
    indexes we can create variables that store their indexes. notice that for..of takes first keys
    and then values. foreach does the opposite
  */

  for (const [points, prize] of prizes) {
    const li = `<li>${points} - ${prize}</li>`;
    ul.insertAdjacentHTML('beforeend', li);
  }

// ############################
// .has()
// ############################

  /* 
  The has() function of the map object accepts a key in string format and returns a boolean value 
  of true if the specified key exists.
  Otherwise, the function returns false.
  */

// ############################
// .delete()
// ############################

// for deleting you have just to do myMap.delete('name') (example)
  </script>
</body>

</html>


<!-- 8:00 -->