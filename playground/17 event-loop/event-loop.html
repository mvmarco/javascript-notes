<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Event Loop</title>
  <link rel="stylesheet" href="../../base.css">
</head>

<body>
  <style>
    .go {
      margin: 5rem;
      background: white;
      padding: 5rem;
      width: 25rem;
      height: 25rem;
      transition: all 0.2s;
    }

    .go.circle {
      border-radius: 50%;
    }

    .go.red {
      background: red;
    }

    .go.purple {
      background: purple;
      color: white;
    }

    .go.fadeOut {
      opacity: 0;
    }
  </style>
  <div class="go">Click Me</div>
  <script>
    /* 
      the first thing to understand before passing to promises, we need to talk about
      how JavaScript is Asynchronous and how the event loop works. Sometimes we hear
      that almost everything in JavaScript is "Asynchronus" or "non-blocking". In order
      to understand what that means, we need to talk about how JavaScript events work.

      Javascript is a single threaded language. Which means, that only one thing can only
      can only be run at a time. it executes code in order and must finish executing a piece code
      before moving onto the next. Some other languages are multi threaded, meaning that they
      can run multiple processes at once. But JavaScript is single threaded, meaning that we can
      run what thing at once.
    */

    console.log('starting'); // this run 1st
    setTimeout(() => {
      console.log('running'); // this run 3rd
    }, 2000);
    console.log('ending'); // this run 2nd

    /* 
      so as we can see they do not run in the order we put them or code them in.
      So it will not first do the "starting", then wait 2 seconds and do the "running"
      and then do the "ending". But instead, what JS will do is: parsing "starting",
      then it will parse the next couple of lines the "running". Notice that there is a
      callback, and pin it a side and come back in two second. And then it goes again
      and run the "ending". What happens next is, two seconds later what comes back is
      the call back that has been queued up. And it will run it for us. That is what is
      referred to as the "call-stack": https://developer.mozilla.org/en-US/docs/Glossary/Call_stack
      for more infos. "call-stack" and the "event-loop" is a pretty complicated thing to understand it
      so to understand it properly watch this video: https://www.youtube.com/watch?v=8aGhZQkoFbQ


      if you go to: http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D
      you can test the process described above, essentially there are three boxes.


      the "call-stack"                                     This is are things that are waiting
      is what actually JavaScript is                       or things that we are listening for
      doing or running                                     such as event handlers, timers etc.
      ------------------------------------                 ------------------------------------
      |                                  |                 |                                  |
      |              CALL-STACK          |                 |            WEB APIs              |
      |                                  |                 |                                  |
      ------------------------------------                 ------------------------------------  
      
      When a click button has finished it 
      or a timer it will be stick into the "call-back queue"
      and sent to the "callstack" when there is nothing else left there
      ------------------------------------
      |                                  |
      |           CALLBACK QUEUE         |
      |                                  |
      ------------------------------------

      in the tool loupe, you can sort of visualize the "call-stack". In general the "call-stack"
      will show you, when you click something, which functions where called upon that. 
      And we know that the "call-stack" will only run one function at the time, but there are
      situations where the functions are running in other spefic moments. That is also why
      JavaScript is referred as "asynchronous". Which means that is not going to stop
      the function that needs more time, but instead put in what is called "web apis". Then it
      will be put in the "call-back queue" and run in the "call-stack" if there is nothing
      before it.

      even if you put 0 milliseconds on the following code lines it will be following the same
      process:

      console.log('starting'); // this run 1st
      setTimeout(() => {
        console.log('running'); // this run 3rd
      }, 0);
      console.log('ending'); // this run 2nd



    */

    function go(e) {
      const el = e.currentTarget;
      // 1. Change the text to GO when clicked.
      el.textContent = 'GO';
      setTimeout(function () {
        // 2. Make it a circle after 2 seconds
        el.classList.add('circle');
        setTimeout(function () {
          // 3. Make it red after 0.5s
          el.classList.add('red');
          setTimeout(function () {
            // 4. make it square after 0.25s
            el.classList.remove('circle');
            setTimeout(function () {
              // 5. make it purple
              el.classList.remove('red');
              el.classList.add('purple');
              setTimeout(function () {
                // 6. fade out after 0.5s
                el.classList.add('invisible');
                setTimeout(function () {
                  console.log('You have reacted the 7th layer of callback hell');
                  el.classList.remove('invisible', 'purple');
                }, 500);
              }, 500);
            }, 500);
          }, 500);
        }, 500);
      }, 500);
    }
  </script>
</body>

</html>