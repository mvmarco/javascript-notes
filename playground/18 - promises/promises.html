<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Promises</title>
  <link rel="stylesheet" href="../../base.css">
</head>

<body>
  <script>
  /* 
    as mentioned in the previous note folder n. 17 the solution for the "call-back hell"
    is the "land of promises", so "promises" has this idea of I owe you something that
    will happen in the future: if you think of a timer, or some data that will be returned
    from an API, or someone giving access to a camera or microphone. When we request those
    things, like a request for a timer to start, a data to be requested or a microphone or 
    camera to give access to, what often we get as when we request this things is not the 
    immediate data back (because takes time) (instead of getting the immediate data
    returned) we would get a "promise". as a metaphone: 'I got a ticket in my hand that is
    a little promise, that says whoooooo i may get a timer at some point, or I have this ticket
    for some data, and eventually at some point I probably may get it back. (it could also
    fail which is called "rejecting").' 

    If you are asking to the user webcam access, like in face detection > pixelated.js in the
    function "populateVideo()" in the "const stream" we put "await" meaning that we have to
    wait for the user to click the accept button before they give us access to their webcam.

    so that happens all the time, we need to wait for something to happen before you can run 
    the rest of the code, and that what is referring to "promise"
    here below we build a function pizza and inside of it will be making a pizza promise
    because you cannot make a pizza instanly (you gotta put the toppings on, bake the thing
    etc. etc. that takes time). So what we can do, if you order a pizza online, they will
    immediately give you some order number, and you cannot eat that, but you know that that
    order number or receipt is a "promise" that they will give it to you when it is finished
  */

  // eslint-disable-next-line no-unused-vars
  function makePizzaToDeliver() {
    const pizzaPromise = new Promise(); // pizza promise
    return pizzaPromise; // return it from your function immediately
  }

  /*
  
    this is the key point (like 41-42). Promises are made immediately(42) but do not resolve
    the request until they are ready(41): until the data comes back, the timer is finished,
    the toppings are on pizza...etc

    in sum:

    "returning" happens immediately (42)
    "resolving" happens when it is done (41)

    a clearer example is here below:
  */

  function makePizza() {
    /*     
      a promise takes a callback function, with two arguments:
      the "resolve" function and the "reject" function.
      always the same order of arguments: 1st resolve 2nd reject 
    */
    const pizzaPromise = new Promise(function (resolve, reject) {
      // 1st when you are ready, you can resolve this promise
      resolve('üçï');
      // 2nd if something went wrong, we can reject this promise
    });
    return pizzaPromise;
  }

  const pizza = makePizza();
  console.log(pizza);
  /*
    from the log you get "Promise {<fulfilled>: ":pizza:"}" but it is not important yet
    what is important that the makePizza() function gives us a "promise" of pizza that
    at some point in the future, you will "resolve" the promise like we did now or
    "reject" because something went wrong. Now we make the example more robust
  */

  function makePizza2(toppings) {
    const pizzaPromise = new Promise(function (resolve, reject) {
      resolve(`Here is your pizza üçï with the toppings: ${toppings.join(' ')}`);
      // 2nd if something went wrong, we can reject this promise
    });
    return pizzaPromise;
  }

  const pepperoniPromise = makePizza2(['pepperoni']);
  const canadianPromise = makePizza2(['pepperoni', 'mushrooms', 'onions']);
  // here we get the two promises
  console.log(pepperoniPromise);
  console.log(canadianPromise);

  /* 
    now the questions is, how do we get the actual pizza. And this is a bit confusing because
    the DEV TOOLS will show us the values when it is "resolved" or not. But in JavaScript if
    you actually want to access the value is not that you can do: 
      console.log(pepperoniPromise.value);                    example
    because it is not gonna work, there would be when we hit "async" or "await" but the
    way we access is that we say:  
  */

  pepperoniPromise.then(function (pizzaValue) {
    console.log(`ah got the pizza value: ${pizzaValue}`);
  });

  /*
    it seems a harder way of dealing with data because we did not introduce 
    any time delays into it. So if now we create a new function makepizza with a delay
    of one second for the pizza to be cooked. 
  */

  function makePizza3(toppings) {
    const pizzaPromise = new Promise(function (resolve, reject) {
      // wait 1 second for the pizza to cook:
      setTimeout(() => {
        resolve(`Here is your pizza üçï with the toppings: ${toppings.join(' ')}`);
      }, 1000);
    });
    return pizzaPromise;
  }
  
  const veggiePizza = makePizza3(['veggies']);
  console.log(veggiePizza); // here the promise with status pending
  veggiePizza.then(function (pizzaValue) {
    // this result will be logged after a second
    console.log(`ah got the pizza value: ${pizzaValue}`);
  });

  /* 
    what is important to notice is that now that we put the setTimeout() when 
    console.log the veggie pizza we immediately get the "promise" with status
    "pending" and after a second we actually get access to our pizza value.

    one more time, we have a regular function that makes a promise and immediately
    that promise is returned, in fact often what you will see instead is:
  */

/* 
  // console.log('First');
  makePizza(['pepperoni'])
    .then(function (pizza) {
      console.log(pizza);
      return makePizza(['ham', 'cheese']);
    })
    .then(function (pizza) {
      console.log(pizza);
      return makePizza(['hot peppers', 'onion', 'feta']);
    })
    .then(function (pizza) {
      console.log(pizza);
      return makePizza(['pineapple']);
    })
    .then(function (pizza) {
      console.log(pizza);
      return makePizza([
        'one',
        'two',
        'three',
        'four',
        'one',
        'two',
        'three',
        'four',
        'one',
        'two',
        'three',
        'four',
      ]);
    })
    .then((pizza) => {
      console.log('All done! here is your last pizza');
      console.log(pizza);
    })
    .catch(handleError);

  // console.log('Right after');

  // Run them Concurrently
  // const pizzaPromise1 = makePizza(['hot peppers', 'onion', 'feta']);
  // const pizzaPromise2 = makePizza(['one', 'two', 'three', 'four', 'one', 'two', 'three', 'four', 'one', 'two', 'three', 'four']);
  // const pizzaPromise3 = makePizza(['ham', 'cheese']);

  // const dinnerPromise = Promise.all([pizzaPromise1, pizzaPromise2, pizzaPromise3]);

  // dinnerPromise.then(function ([hottie, garbagePail, hamAndCheese]) {
  //   console.log(hottie, garbagePail, hamAndCheese);
  // });

  // const firstPizzaPromise = Promise.race([pizzaPromise1, pizzaPromise2, pizzaPromise3]);

  // firstPizzaPromise.then(pizza => {
  //   console.log('You must be hungry, here is the first one ready');
  //   console.log(pizza);
  // })

  function handleError(err) {
    console.log('Ohh noooo!!');
    console.log(err);
  }

  makePizza(['cheese', 'pineapple'])
    .then((pizza) => {
      console.log(pizza);
    })
    .catch(handleError);

  const p1 = makePizza(['pep']);
  const p2 = makePizza(['pineapple']);

  const dinnerPromise2 = Promise.allSettled([p1, p2]);

  dinnerPromise2.then((results) => {
    console.log(results);
  }); */
  </script>
</body>

</html>