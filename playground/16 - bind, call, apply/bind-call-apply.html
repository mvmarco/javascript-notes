<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Bind Call and Apply!</title>
  <link rel="stylesheet" href="../../base.css">
</head>

<body>
  <p>Hey</p>
  <button>Click me</button>
  <div class="wrapper">
    <p>Hey im in a wrapper</p>
  </div>

  <script>
    /*  
      "bind", "call" and "apply" are function used to change the scope of what "this" is
      equal to, inside of a function or inside of a method. They are not used so much
      but many people do and some tricky interview questions focus on this topic
    */

// ############################
// BIND
// ############################
    const person = {
      name: 'Marco',
      sayHi() {
        console.log(this); // this will log all the properties of the person object, property and function
        console.log(`hey this is ${this.name}`); // this will log this string
        return `hey ${this.name}`; // this will return the string
      },
    };

    /* 
      if in the console you call: person.sayHi() and when methods are called the way the work is
      that they look to the left of the dot and see what they are bound against

      so now if we are gonna take the sayHi() method and put it outside in its own variable
      so it is defined outside:

      const sayHi = person.sayHi;

      and in the console we do: sayHi()  as result we just get  "hey "
      because person.sayHi is stored inside another variable and we are not calling
      the function directly on the object. so we just get the return of the method
      and not what is bound with the keyword "this" like the name.

      another example: if you do: person.sayHi() is bounded to the person itself, the instance
      but if you do: sayHi() is bounded to the window, because there was nothing on its left
      that was bound to. It was not referring to any instance, "this" refers to instance,
      so when it is not bounded "this" is not read.

      the "this" keyword is only defined where the function is being called
      and not where the function has been defined. So even though we defined the sayHi() 
      function inside of an object, it is not bound it unless we call it as a method of an
      object -> like person.sayHi()

      what we can do is use the "bind" keyword to change where the "this" keyword is
      defined. In other words, the "bind" keyword is used to change what actually
      the "this" keyword is equal to or bound to.

      so if we do:

      const sayHi = person.sayHi.bind(person);

      what is says is, creating a function called sayHi() for the person stored into
      const sayHi, but binded the the "person" object. In other words, when called the "this" key
      word it will refered to the "person" passed in the bind() function

      so now if we run in the console: sayHi() we get "hey Marco" 

      it works because we changed what "this" is equal to by binding to another object or
      the direct one. So why would that be useful? because sometimes we want to use a method
      of an object with some other informations. Example below:
      
      The bind() method allows an object to borrow a method from another object without
      making a copy of that method. This is known as function borrowing in JavaScript.
      // .bind({ name: 'Harry' });
    */

    // how would I use the sayHi() method for another object such as Jenna?
    const person2 = {
      name: 'Marco',
      sayHi() {
        console.log(this); // this will log all the properties of the person object, property and function
        console.log(`hey this is ${this.name}`); // this will log this string
        return `hey ${this.name}`; // this will return the string
      },
    };
    
    const jenna = { name: 'Jenna' };
    // the solution would be to bind the sayHi() to jenna

    const sayHi = person2.sayHi.bind(jenna); // jenna is what this will be focus on
    console.log(sayHi()); // this will run "hey Jenna"

    /* 
      sayHi is a function while bind() is method that lives inside any functions
      and says change the "this" keyword to what there is inside of that object that you pass
    */

    // ############################
    // BIND QUERY SELECTOR EXAMPLE
    // ############################

    // if you have this costant:
    const $ = document.querySelector;
    // and in the console you run: $ you get the same result as running: document.querySelector
    // it is the same exact thing: document.querySelector === $    :true

    /* 
      above this page we have  paragrap if you wanna get it and do in the console:

      $('p'); you get error, somewhere under the hood in querySelector needs to know
      where to look for the thing you are selecting (like the document). So if we
      have the wrapper class we can search it in the document and use the wrapper
      to search the paragrap as follow:
      
    */

    const wrapper = document.querySelector('.wrapper');
    const p = wrapper.querySelector('p');
    console.log(p);
    /*
      so querySelector is a function that needs to know where should look inside of
      for the selector, and it is the resons why it knows where it scopes to. This can be globally
      with the document or in a subset of the dom which is the wrapper, then it knows
      to look inside of the wrapper because the querySelector says "this" which will be equal
      either to the wrapper or the document.

      but the resons why $.('p') is not working is because we somehow removed the power of the
      querySelector, we called it direcly on a variable, and there is nothing on the left of the dot
      called directly, there is just a variable. We are taken away the object which the method
      was called against  and it is not bound to anything 
    */

    /* 
      the way we fix that is with the usage of "bind" and then we manually pass reference
      to the thing we want "this" to be equal to. by calling bind against querySelector, 
      we say when the $2 function is run, use `document` as the `this` value. so basically
      you associated the "this" value to a variable, because the method is not called directly
      to that variable.
    */
    const $2 = document.querySelector.bind(document);
    const lookFor = document.querySelectorAll.bind(document);
    console.log($2('p'));
    console.log(lookFor('p'));

    const bill = {
      total: 1000,
      calculate(taxRate) {
        console.log(this);
        return this.total + this.total * taxRate;
      },
      describe(mealType, drinkType, taxRate) {
        console.log(
          `Your meal of ${mealType} with a drink of ${drinkType} was ${this.calculate(
            taxRate
          )}`
        );
      },
    };

    const total = bill.calculate(0.13);
    const calc = bill.calculate.bind({ total: 500 }, 0.06);

    console.log(calc());
    const total2 = bill.calculate.call({ total: 500 }, 0.06);
    console.log(total2);

    const total3 = bill.calculate.apply({ total: 325 }, [0.6]);
    console.log(total3);

    const myMeal = bill.describe.call(bill, 'pizza', 'beer', 0.13);
    console.log(myMeal);
    const myMeal2 = bill.describe.apply(bill, ['pizza', 'beer', 0.13]);
    console.log(myMeal2);
  </script>
</body>

</html>


<!-- 6 -->