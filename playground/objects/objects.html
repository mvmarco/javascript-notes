<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title></title>
  <link rel="stylesheet" href="../../base.css">
</head>

<body>
  <input type="text" name="first" value="wes">

  <script src="https://unpkg.com/lodash"></script>
  <script>
// ############################
// OBJECTS
// ############################

/* 

everything in JS is an object. Objects allow us to group together properties (or keys) and values.
the function is to store data or create a custom type. What is important is that object are used where
the order of property does not matter. Never rely on the order of the property in an object to be 
mainteined in the same way. Different browser have different orders.

the object literal syntax convention to write object is: 

const person = {
  age: 100,
  name: 'marco',
};

property on the left and value on the right. The value can be any type (number, boolean, numbers
variables, arrays a etc etc check the lesson types)

// as mentioned above you can also pass a vaiable as an object

const age = 100;
const person = {
  age = age,
  name: 'marco',
};

// if you pass a variable with the same name as the value you can just do:

const age = 100;
const person = {
  age,
  name: 'marco',
};


// if you wanna include a property with dashes or number or spaces has to be passed as a string
the console will read is a property. Otherwise wont work. you cannot have variables with dashes
but you can have properties. Also as mentioned you cannot trust the order, in fact 777 in the console
will be on top. NEVER TRUST THE ORDER. ALWAYS PUT THE COMMA ALSO ON THE LAST ONE, GOOD PRACTICE

const age = 100;
const person = {
  age,
  name: 'marco',
  '777': true, // the number will be corrected without a string
  'really cool': false,
  'test-property-with-dash': 'testing',
};

console.log(person);
*/

// we can also add sub-properties with an object nested inside the main object
// we can also add functions
const age = 100;
const wes = {
  age,
  name: 'wes',
  properyToCheck: 'NEVER',
  'cool-dude': true,
  'really cool': false,
  777: true,
  dog: 'snicker',
  // sub-properties with an object
  clothing: {
    shirts: 10,
    pants: 2,
  },
  // functions properties
  sayHello(greeting = 'Hey') {
    return `${greeting} ${this.name}`;
  },
};

// ############################
// ACCESS PROPERTIES
// ############################

// how to add new property or update
wes.job = 'Web Developer';
wes.age = 50; // age is a costant but you can update its value and not create another age const. That is what costants are
console.log(wes.clothing);
// you can also go deeper in the nested object
console.log(wes.clothing.shirts);
console.log(wes); // you get the whole object

/*
you can also access properties with
console.log(wes['age']);
but prettier fix it: console.log(wes.age);

but it is for explaining that if you do:
*/

// const propertyToCheck = prompt('What do you wanna check');

/* 
it will replace the input string of the prompt with whatever property you have in wes
it means that strings are converted in properties
you use square brakets when the property to check is an input from the user for instance
and you are not sure what that would be
or when you have to console.log the properties with custom names '777' or 'cool-dude' or 'really cool'


console.log(wes[propertyToCheck]);
console.log(wes['777']); // for number it works also without  quotes: 777
console.log(wes['really cool']);

*/

// ############################
// ACCESS PROPERTIES: FREEZE
// ############################

/*

there is a way of let an object stays with its properties and dont let anyone change them
the way is to use freeze.

const wesFroze = Object.freeze(wes)

now if you go in the console and try to update: wesFroze.age = 100
calling wesFroze will tell you again that the age is 50

*/

// #####################################
// CHECKING IF PROPERTIES ARE PRESENT
// #####################################

const nameInput = document.querySelector('[name="first"]');
const name = nameInput ? nameInput.value : '';
console.log(name);

// ############################
// DELETE PROPERTIES
// ############################

/* 
to delete properties you can use the delete keyword before the property you wanna delete
you can either store it in a variable or in a console.log to check if the result of
deletion is true or false:

console.log(delete wes.job); 

if you just call wes.job in the console will be undefined

This does not mean that if you do:

// wes.age = undefined; 
// wes.age = null;

you will delete them, but instead means you just update their value and they are still present
*/

// ############################
// METHODS
// ############################

let name1 = 'wes';
let name2 = 'wes';

console.log(name1 === name2);
name1 = 'scott';
console.log(name1 === name2);
// update name1 to be what is name2
name1 = name2;
console.log(name1 === name2);
name2 = name1;
name2 = 'westopher';

const person1 = {
  first: 'wes',
  last: 'bos',
  clothing: {
    shirts: 10,
    pants: 2,
  },
};
const person2 = {
  first: 'wes',
  last: 'bos',
};

// const person3 = person1;
// person3.first = 'Larry';
// console.log(person3.first);
// console.log(person1.first);
// const person3 = { ...person1 };
const person3 = _.cloneDeep(person1);
person3.first = 'Larry';

person3.clothing.shirts = 100;

const meatInventory = {
  bacon: 2,
  sausage: 3,
  oyster: 10,
};

const veggieInventory = {
  lettuce: 5,
  tomatoes: 3,
  oyster: 15,
};

const inventory = {
  ...meatInventory,
  ...veggieInventory,
};

function doStuff(data) {
  data = 'something else';
  console.log(data);
}

function doStuff2(data) {
  data.tomatoes = 10000000000;
  console.log(data);
}

doStuff2(inventory);
  </script>
</body>

</html> 