<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>

  </title>
  <link rel="stylesheet" href="../../base.css">
</head>

<body>
  <script>
    const toppings = [
  'Mushrooms ',
  'Tomatoes',
  'Eggs',
  'Chili',
  'Lettuce',
  'Avocado',
  'Chiles',
  'Bacon',
  'Pickles',
  'Onions',
  'Cheese',
];

    const students = [
      {
        id: '11ce',
        first_name: 'Dall',
        last_name: 'Puckring',
      },
      {
        id: '2958',
        first_name: 'Margarete',
        last_name: 'Brandi',
      },
      {
        id: '565a',
        first_name: 'Bendicty',
        last_name: 'Woodage',
      },
      {
        id: '3a16',
        first_name: 'Micki',
        last_name: 'Mattes',
      },
      {
        id: 'f396',
        first_name: 'Flory',
        last_name: 'Gladeche',
      },
      {
        id: 'de5f',
        first_name: 'Jamill',
        last_name: 'Emilien',
      },
      {
        id: '54cb',
        first_name: 'Brett',
        last_name: 'Aizikowitz',
      },
      {
        id: '9135',
        first_name: 'Lorry',
        last_name: 'Smallman',
      },
      {
        id: '978f',
        first_name: 'Gilly',
        last_name: 'Flott',
      },
    ];

    const people = [
      {
        birthday: 'April 22, 1993',
        names: {
          first: 'Keith',
          last: 'Buckley',
        },
      },
      {
        birthday: 'January 3, 1975',
        names: {
          first: 'Larry',
          last: 'Heep',
        },
      },
      {
        birthday: 'February 12, 1944',
        names: {
          first: 'Linda',
          last: 'Bermeer',
        },
      },
    ];

    const buns = ['egg', 'wonder', 'brioche'];

    const meats = {
      beyond: 10,
      beef: 5,
      pork: 7,
    };

    const prices = {
      hotDog: 453,
      burger: 765,
      sausage: 634,
      corn: 234,
    };

    const orderTotals = [342, 1002, 523, 34, 634, 854, 1644, 2222];

    const feedback = [
      { comment: 'Love the burgs', rating: 4 },
      { comment: 'Horrible Service', rating: 2 },
      { comment: 'Smoothies are great, liked the burger too', rating: 5 },
      { comment: 'Ambiance needs work', rating: 3 },
      { comment: 'I DONT LIKE BURGERS', rating: 1 },
    ];

    const faces = ['😃', '🤠', '🤡', '🤑', '😵', '🌞', '🐶', '😺'];

    const inventory = [
      { type: 'shirt', price: 4000 },
      { type: 'pants', price: 4532 },
      { type: 'socks', price: 234 },
      { type: 'shirt', price: 2343 },
      { type: 'pants', price: 2343 },
      { type: 'socks', price: 542 },
      { type: 'pants', price: 123 },
    ];

    // ############################################
    // LOOPING METHODS CONTINUOS FROM PREVIOUS FILE
    // ############################################

    /* 
      there are different ways to loop in JS
      the most common way to loop over something is looping
      over an array. Most of the loopings work in the same
      way, we use a method that lives in our array and we pass
      a callback function. The callback function runs once for
      every/each item of the array giving acces to each individual
      item
    */

    // #######################
    // FOREACH
    // #######################

    /*
      the most basic, .forEach() and you pass a callback the will be run once for every
      single item. Whether you define the function outside or inside the method
    */

    const logToppings = (topping) => {
      console.log(topping);
      // debugger; // check the call stack: tells we are in logToppings function
      /*
        if you clicked on top of the page the curved arrow with the dot
        the function keeps running and gives us different scope (results) 
      */
    };
    console.log('HERE WE CONSOLE EACH TOPPING WITH AN CALLBACK FUNCTION');
    toppings.forEach(logToppings); // here we log every single topping item from the array

    // we can also put the function inside the forEach:

    console.log('HERE WE CONSOLE EACH TOPPING WITH AN INSIDE FUNCTION');
    toppings.forEach((topping) => console.log(topping));

    /* 
      wheter the function is a callback. When we define the function
      we put one parameter (topping) but when we call it or put the 
      function into the forEach JS will take into consideration the first argument. 
      That is also why when we pass the function directly into the forEach 
      there is no need to give a name to the function. The argument is the one that counts 
    */

    /* 
      by default the forEach takes into consideration the first argument as a value
      of the array, the second index and the third the array
    */

    console.log(
      'HERE WE CONSOLE EACH TOPPING, INDEX AND ARRAY WITH AN INSIDE FUNCTION'
    );

    toppings.forEach((topping, index, array) => console.log(topping, index, array));
    // check the console.

    /* 
      // a small exercise would be:
      // log the topping
      // log the prev topping if there is one
      // log the next topping if there is one
      // if its the last item in the array, say good bye
    */
    console.log('☪☪☪☪☪☪☪☪☪☪☪ EXERCISE PRACTICE ☪☪☪☪☪☪☪☪☪☪☪');

    toppings.forEach((topping, index, originalArray) => {
      // log the topping
      console.log('loggin each topping');
      console.log(topping);

      // log the next topping if there is one
      const nextTopping = originalArray[index + 1];
      if (nextTopping) {
        console.log('loggin next topping');
        console.log(originalArray[index + 1]);
        console.log(
          '--division line--🍕first and next topping🍕--division line-- '
        );
      }

      /* 
        we can also use a ternary: 
        nextTopping ? console.log(originalArray[index + 1]) : null;

      */
    
      // log the prev topping if there is one
      const prevTopping = originalArray[index - 1];

      console.log('loggin previous topping from the original result');
      // eslint-disable-next-line no-unused-expressions
      prevTopping ? console.log(originalArray[index - 1]) : null;

      // if its the last item in the array, say good bye

      /* 
      const last = originalArray.length - 1;
      console.log('logging the last item of the array and replace it with goodbye');
      last ? console.log('goodbye') : null;

      this is not completely right because I will get the last result 
      at each single iteration of the array. If you wanna get goodbye only
      at the last iteration (last item) the index (current index or index of each iteration)
      has to be equal to the last item of the array, only then you say goodnbye
      like as follow:     
      */
    
      const lastIterationItem = index === originalArray.length - 1;
      // eslint-disable-next-line no-unused-expressions
      lastIterationItem ? console.log('goodbye') : console.log('nextitem');
    
      /*
        you can also abuse of the conditional &&
        if the first condition is true it will keep going
        if not it will stop

        // index === originalArray.length && console.log('Goodbye');
      */
    });

    /* 
      forEach is different thant the other looping methods
      because it does not return any value stored in somewhere
      like if you do:

      const result = toppings.forEach(logToppings)
      console.log(result); // you will get undefined
      forEach does not return anything to you
      it does some work for every item that is in that array.
    */

    /* 
      forEach is handy when you wanna loop over some data and do something
      with each piece of data, whether is to log the value, index or the array itself
      or associating an event listener. In some cases when you manipulate the data
      we fall of in a category called SIDE EFFECTS. 
      
      A *SIDE EFFECT* is: when you are inside a function (can be a forEach but not always)
      and you reach outside of a function, like an array, and you do something else. 

      A side-effect is when a function mutates (changes) something that doesn't exist inside the function.

      "reaching outside" just means that the function accesses or 
      changes something that doesn't exist in the function declaration.

      The are other loops that are taking in data, do something with that data and then returning
      that data that has modified as a new output. Which are the following:
    */

    // ########################################
    // THE BIG THREE: MAP, FILTER AND REDUCE
    // ########################################

    /* 
      map, filter and reduce are loops that are taking in data, do something with that data and 
      then returning that data that has modified without mutating the original. 
      Examples can be filtering data, looking for something that you want (find).
      These guys are defined pure functions: taking data and returning data. And do not reach
      outside of themselves to do that
    */

    // ###############
    // MAP
    // ###############

    /* 
      MAP is a machine in a factory is taking in data, perform an operation and spits out the output
      to the other side. Map produce out always the same length of the array has started with.
    */

    // const faces = ['😃', '🤠', '🤡', '🤑', '😵', '🌞', '🐶', '😺'];

    const addArms = (face) => `👋 ${face} 👋 `;
    console.log(addArms('😋'));

    const toys = faces.map(addArms);
    /* 
      Arguments are forwarded automatically in JavaScript. 
      .map will call the function and pass the arguments.
    */
    console.log(toys);

    // another example

    const names = ['marco', 'olivia', 'lapo'].map((name) => `${name} wow`);
    // the argument of map is each item of the array, wow is added to each ot them
    console.log(names);

    // another example were we create the function outside
    const wowify = (name) => `${name} wow`;
    // here we want also the first letter upperCase();
    
    /* 
      const toUppercase = (word) => word[0].toUpperCase() + word.slice(1);
      not a good practice because of the + used to addition and not interpolation
    */
    const toUppercase = (word) => `${word[0].toUpperCase()}${word.slice(1)}`;
    // we do word.slice(1) because before we took only the first letter and now
    // we need to add the rest of each word, starting from index 1
    // we can add multiple map
    const namesTwo = ['mmmmarco', 'oooolivia', 'llllapo']
      .map(wowify)
      .map(toUppercase); // notice only one semicolon ; at the end of the last map
    console.log(namesTwo);

    // another example: const orderTotals = [342, 1002, 523, 34, 634, 854, 1644, 2222];
    // adding tax to it:
    
    /*  
      const orderTotalWithTax = orderTotals.map((total) => 1);
      console.log(orderTotalWithTax); 

      this will replace everything with 1 into a new array
    */
    
    // adding tax to it properly:
    const orderTotalWithTax = orderTotals.map((total) => total + 1.13);
    console.log(orderTotalWithTax);
    
    /*     
      EXAMPLE TO HOW TO USE MAP AND FOREACH TO BUILD A COWBOY
      array(3).fill fill 3 times what you pass

      function attachBody(face, body) {
          return `
        ${face}
        ${body.repeat(3)}
        ${Array(3).fill(body).join(' ')}
        👇🏽 ${body.repeat(2)}👇🏽
        ${Array(2).fill(body).join('   ')}
        ${Array(2).fill(body).join('   ')}
        👢👢
              `;
      }
      
      faces.map((face) => attachBody(face, '🍟')).forEach((body) => console.log(body)); 
    */

    // ###############
    // FILTER
    // ###############
    
    // ###############
    // REDUCE
    // ###############
  </script>
</body>

</html>


<!-- 12:00 -->