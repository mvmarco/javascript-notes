<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>

  </title>
  <link rel="stylesheet" href="../../base.css">
</head>

<body>
  <script>
    const toppings = [
  'Mushrooms ',
  'Tomatoes',
  'Eggs',
  'Chili',
  'Lettuce',
  'Avocado',
  'Chiles',
  'Bacon',
  'Pickles',
  'Onions',
  'Cheese',
];

    const students = [
      {
        id: '11ce',
        first_name: 'Dall',
        last_name: 'Puckring',
      },
      {
        id: '2958',
        first_name: 'Margarete',
        last_name: 'Brandi',
      },
      {
        id: '565a',
        first_name: 'Bendicty',
        last_name: 'Woodage',
      },
      {
        id: '3a16',
        first_name: 'Micki',
        last_name: 'Mattes',
      },
      {
        id: 'f396',
        first_name: 'Flory',
        last_name: 'Gladeche',
      },
      {
        id: 'de5f',
        first_name: 'Jamill',
        last_name: 'Emilien',
      },
      {
        id: '54cb',
        first_name: 'Brett',
        last_name: 'Aizikowitz',
      },
      {
        id: '9135',
        first_name: 'Lorry',
        last_name: 'Smallman',
      },
      {
        id: '978f',
        first_name: 'Gilly',
        last_name: 'Flott',
      },
    ];

    const people = [
      {
        birthday: 'April 22, 1993',
        names: {
          first: 'Keith',
          last: 'Buckley',
        },
      },
      {
        birthday: 'January 3, 1975',
        names: {
          first: 'Larry',
          last: 'Heep',
        },
      },
      {
        birthday: 'February 12, 1944',
        names: {
          first: 'Linda',
          last: 'Bermeer',
        },
      },
    ];

    // eslint-disable-next-line no-unused-vars
    const buns = ['egg', 'wonder', 'brioche'];

    // eslint-disable-next-line no-unused-vars
    const meats = {
      beyond: 10,
      beef: 5,
      pork: 7,
    };

    // eslint-disable-next-line no-unused-vars
    const prices = {
      hotDog: 453,
      burger: 765,
      sausage: 634,
      corn: 234,
    };

    const orderTotals = [342, 1002, 523, 34, 634, 854, 1644, 2222];

    // eslint-disable-next-line no-unused-vars
    const feedback = [
      { comment: 'Love the burgs', rating: 4 },
      { comment: 'Horrible Service', rating: 2 },
      { comment: 'Smoothies are great, liked the burger too', rating: 5 },
      { comment: 'Ambiance needs work', rating: 3 },
      { comment: 'I DONT LIKE BURGERS', rating: 1 },
    ];

    const faces = ['😃', '🤠', '🤡', '🤑', '😵', '🌞', '🐶', '😺'];

    const inventory = [
      { type: 'shirt', price: 4000 },
      { type: 'pants', price: 4532 },
      { type: 'socks', price: 234 },
      { type: 'shirt', price: 2343 },
      { type: 'pants', price: 2343 },
      { type: 'socks', price: 542 },
      { type: 'pants', price: 123 },
    ];

    // ############################################
    // LOOPING METHODS CONTINUOS FROM PREVIOUS FILE
    // ############################################

    /* 
      there are different ways to loop in JS
      the most common way to loop over something is looping
      over an array. Most of the loopings work in the same
      way, we use a method that lives in our array and we pass
      a callback function. The callback function runs once for
      every/each item of the array giving acces to each individual
      item
    */

    // #######################
    // FOREACH
    // #######################

    /*
      the most basic, .forEach() and you pass a callback the will be run once for every
      single item. Whether you define the function outside or inside the method
    */

    const logToppings = (topping) => {
      console.log(topping);
      // debugger; // check the call stack: tells we are in logToppings function
      /*
        if you clicked on top of the page the curved arrow with the dot
        the function keeps running and gives us different scope (results) 
      */
    };
    console.log('HERE WE CONSOLE EACH TOPPING WITH AN CALLBACK FUNCTION');
    toppings.forEach(logToppings); // here we log every single topping item from the array

    // we can also put the function inside the forEach:

    console.log('HERE WE CONSOLE EACH TOPPING WITH AN INSIDE FUNCTION');
    toppings.forEach((topping) => console.log(topping));

    /* 
      wheter the function is a callback. When we define the function
      we put one parameter (topping) but when we call it or put the 
      function into the forEach JS will take into consideration the first argument. 
      That is also why when we pass the function directly into the forEach 
      there is no need to give a name to the function. The argument is the one that counts 
    */

    /* 
      by default the forEach takes into consideration the first argument as a value
      of the array, the second index and the third the array
    */

    console.log(
      'HERE WE CONSOLE EACH TOPPING, INDEX AND ARRAY WITH AN INSIDE FUNCTION'
    );

    toppings.forEach((topping, index, array) => console.log(topping, index, array));
    // check the console.

    /* 
      // a small exercise would be:
      // log the topping
      // log the prev topping if there is one
      // log the next topping if there is one
      // if its the last item in the array, say good bye
    */
    console.log('☪☪☪☪☪☪☪☪☪☪☪ EXERCISE PRACTICE ☪☪☪☪☪☪☪☪☪☪☪');

    toppings.forEach((topping, index, originalArray) => {
      // log the topping
      console.log('loggin each topping');
      console.log(topping);

      // log the next topping if there is one
      const nextTopping = originalArray[index + 1];
      if (nextTopping) {
        console.log('loggin next topping');
        console.log(originalArray[index + 1]);
        console.log(
          '--division line--🍕first and next topping🍕--division line-- '
        );
      }

      /* 
        we can also use a ternary: 
        nextTopping ? console.log(originalArray[index + 1]) : null;

      */
    
      // log the prev topping if there is one
      const prevTopping = originalArray[index - 1];

      console.log('loggin previous topping from the original result');
      // eslint-disable-next-line no-unused-expressions
      prevTopping ? console.log(originalArray[index - 1]) : null;

      // if its the last item in the array, say good bye

      /* 
      const last = originalArray.length - 1;
      console.log('logging the last item of the array and replace it with goodbye');
      last ? console.log('goodbye') : null;

      this is not completely right because I will get the last result 
      at each single iteration of the array. If you wanna get goodbye only
      at the last iteration (last item) the index (current index or index of each iteration)
      has to be equal to the last item of the array, only then you say goodnbye
      like as follow:     
      */
    
      const lastIterationItem = index === originalArray.length - 1;
      // eslint-disable-next-line no-unused-expressions
      lastIterationItem ? console.log('goodbye') : console.log('nextitem');
    
      /*
        you can also abuse of the conditional &&
        if the first condition is true it will keep going
        if not it will stop

        // index === originalArray.length && console.log('Goodbye');
      */
    });

    /* 
      forEach is different thant the other looping methods
      because it does not return any value stored in somewhere
      like if you do:

      const result = toppings.forEach(logToppings)
      console.log(result); // you will get undefined
      forEach does not return anything to you
      it does some work for every item that is in that array.
    */

    /* 
      forEach is handy when you wanna loop over some data and do something
      with each piece of data, whether is to log the value, index or the array itself
      or associating an event listener. In some cases when you manipulate the data
      we fall of in a category called SIDE EFFECTS. 
      
      A *SIDE EFFECT* is: when you are inside a function (can be a forEach but not always)
      and you reach outside of a function, like an array, and you do something else. 

      A side-effect is when a function mutates (changes) something that doesn't exist inside the function.

      "reaching outside" just means that the function accesses or 
      changes something that doesn't exist in the function declaration.

      The are other loops that are taking in data, do something with that data and then returning
      that data that has modified as a new output. Which are the following:
    */

    // ########################################
    // THE BIG THREE: MAP, FILTER AND REDUCE
    // ########################################

    /* 
      map, filter and reduce are loops that are taking in data, do something with that data and 
      then returning that data that has modified without mutating the original. 
      Examples can be filtering data, looking for something that you want (find).
      These guys are defined pure functions: taking data and returning data. And do not reach
      outside of themselves to do that
    */

    // ###############
    // MAP
    // ###############

    /* 
      MAP is a machine in a factory is taking in data, perform an operation and spits out the output
      to the other side. Map produce out always the same length of the array has started with.
    */

    // const faces = ['😃', '🤠', '🤡', '🤑', '😵', '🌞', '🐶', '😺'];

    const addArms = (face) => `👋 ${face} 👋 `;
    console.log(addArms('😋'));

    const toys = faces.map(addArms);
    /* 
      Arguments are forwarded automatically in JavaScript. 
      .map will call the function and pass the arguments.
    */
    console.log(toys);

    // another example

    const names = ['marco', 'olivia', 'lapo'].map((name) => `${name} wow`);
    // the argument of map is each item of the array, wow is added to each ot them
    console.log(names);

    // another example were we create the function outside
    const wowify = (name) => `${name} wow`;
    // here we want also the first letter upperCase();
    
    /* 
      const toUppercase = (word) => word[0].toUpperCase() + word.slice(1);
      not a good practice because of the + used to addition and not interpolation
    */
    const toUppercase = (word) => `${word[0].toUpperCase()}${word.slice(1)}`;
    // we do word.slice(1) because before we took only the first letter and now
    // we need to add the rest of each word, starting from index 1
    // we can add multiple map
    const namesTwo = ['mmmmarco', 'oooolivia', 'llllapo']
      .map(wowify)
      .map(toUppercase); // notice only one semicolon ; at the end of the last map
    console.log(namesTwo);

    // another example: const orderTotals = [342, 1002, 523, 34, 634, 854, 1644, 2222];
    // adding tax to it:
    
    /*  
      const orderTotalWithTax = orderTotals.map((total) => 1);
      console.log(orderTotalWithTax); 

      this will replace everything with 1 into a new array
    */
    
    // adding tax to it properly:
    const orderTotalWithTax = orderTotals.map((totall) => totall + 1.13);
    console.log(orderTotalWithTax);
    
    /*     
      EXAMPLE TO HOW TO USE MAP AND FOREACH TO BUILD A COWBOY
      array(3).fill fill 3 times what you pass

      function attachBody(face, body) {
          return `
        ${face}
        ${body.repeat(3)}
        ${Array(3).fill(body).join(' ')}
        👇🏽 ${body.repeat(2)}👇🏽
        ${Array(2).fill(body).join('   ')}
        ${Array(2).fill(body).join('   ')}
        👢👢
              `;
      }
      
      faces.map((face) => attachBody(face, '🍟')).forEach((body) => console.log(body)); 
    */

    // map can be used also for objects specifically in the case of APIs with JSON

    /* 
      const people = [
        {
          birthday: 'April 22, 1993',
          names: {
            first: 'Keith',
            last: 'Buckley',
          },
        },
        {
          birthday: 'January 3, 1975',
          names: {
            first: 'Larry',
            last: 'Heep',
          },
        },
        {
          birthday: 'February 12, 1944',
          names: {
            first: 'Linda',
            last: 'Bermeer',
          },
        },
      ]; 
    */
    const cleanPeople = people.map((person) => {
      console.log(person); // you get each object
      // get their birthday
      // if you dont pass anything to date you get the today's date
      // getTime(); is a method that retrives the date and convert it in millisecond
      const birthday = new Date(person.birthday).getTime();
      // if you do console.dir(birthday) you can see all the methods that exist on a Date Object
      console.dir(birthday);
      // figure out how old they are using the date of today too
      const now = new Date(); // here we get date of today
      console.log(now);
      /* 
        in order to make the substraction we need to take:
        the date of today - the milliseconds of the birthday = age in milliseconds
        we need to convert it in years:
        age in milliseconds/ divided per how many milliseconds there are in a year:
        1000 millisecond in a second *
        60 second in a minute *
        60 min in a hour *
        24 hour in a day *
        365 days in a year  =

        31,536,000,000 millisecond in a year
      */
      const age = Math.floor((now - birthday) / 31536000000);
      console.log(age);
      // check https://date-fns.org/ to figure out time between dates in  a different way
    
      /* 
        if you do: now.getTime() you get the numbers of milliseconds from when the heart was created
        you can go here: https://epoch.now.sh/ you can convert any date to any time stamp     
      */
      // return their full name and bday in an object
      return {
        age, // a refactored version of age: age,
        name: `${person.names.first} ${person.names.last}`,
      };
    });

    console.table(cleanPeople);

    // in sum map takes data that does not look how you like it, you change it and spit out back

    // ###############
    // FILTER
    // ###############

    /* 
      filter is a way of finding the data that you need.
      For instance finding people that are older than 40 years old
    */

    const over40 = cleanPeople.filter((person) => person.age > 40);
    console.log(over40); // you looped over each person and get the results
    // if there are no people you will get an empty array

    if (over40) {
      console.log('there are people over 40');
    }

    /* 
      find() works in the same exact way of filter() with the only exeption that
      find() returns only one item that you are looking for and not all of them
      like with filter().

      filter() will return an array
      find() the actual item/value you where looking for
    */

    // example to find the student with ID of 565a
    const student565a = students.find((studentt) => studentt.id === '565a');
    console.log(student565a);

    // we could also make it with a higher order function: to use it for everyID

    const findID = (id) =>
      // eslint-disable-next-line no-unused-vars
      function isStudent(stud) {
        return stud.id === id;
      };

    const student = students.find(findID('565a'));
    console.log(student);

    // log the json/object student
    console.log(students);

    // find a function that find by firstname and lastname
    // it takes a key and a value
    const findByProp = (property, propertyWeAreLookingFor) =>
      function isStudent(studenttt) {
        // we use [] and not a .property because what we are looking for is passed as a variable
        return studenttt[property] === propertyWeAreLookingFor;
      };
    
    const student2 = students.find(findByProp('id', '565a'));
    const student3 = students.find(findByProp('first_name', 'Micki'));
    console.log(student2);
    console.log(student3);
    // ###############
    // REDUCE
    // ###############

    /* 
      map() will take in items and return a transformed version
      filter() will take in items return a subset of those items
      while reduce() it is the trickiest because it does multiple things 
      and can be used in different contexts. In sum it takes in an array 
      and return to us a result or a single value
    */

    // an example using: const orderTotals = [342, 1002, 523, 34, 634, 854, 1644, 2222];

    let total = 0;
    orderTotals.forEach((eachTotal) => (total += eachTotal)); // you get the sum of every number

    /* 
      this is kind of messy because the method (forEach) is using an external variable to make
      the sum. This is a side effect: updating a variable that is outside of the function
      and it is not the best way apparently.

      reduce() will loop over every single item in that array and keep running a total of these
      numbers. Try to google in google image: map filter reduce. From there you see that
      reduce takes an array of items and compile this items in a reduced version. 
      
      Making a reduction in cooking is cooking a bunch of stuff, let it simmer for a while
      until it becomes one thick thing. Reduce means reducing something smaller than the original
      value.
    */
    
    /* 
      reduce() needs a call back function that takes in 2 arguments
      an accumulator: the thing that has been handed to you from the last instance of the loop
      the currentValue: the current item taken from the array
    */
    console.log(orderTotals);
    // here callback function that will run once for every single item in the array for the reduce method
    const tallyNumbers = (tally, currentTotal) => {
      console.log(`the current tally is ${tally}`);
      console.log(`the currentTotal (value) is ${currentTotal}`);
      console.log('------------');
      // whichever value you return here is gonna be the accumulator
      return tally + currentTotal;
    };

    // eslint-disable-next-line no-unused-vars
    const AllOrders = orderTotals.reduce(tallyNumbers, 0); // zero is means that the first tally start at 0
    // if you don't pass anything (we passed the zero) it will take first number

    /* 
      in sum reduce will loop over items in an array and every single time you loop over you have
      the option to return a value that can be used to accumulate values, or to put them into a 
      single value.

      now if we want the total we can console log AllOrders:
    */

    console.log(AllOrders);

    /* 
      another example would be using inventory which is an array of objects: 
      const inventory = [
        { type: 'shirt', price: 4000 },
        { type: 'pants', price: 4532 },
        { type: 'socks', price: 234 },
        { type: 'shirt', price: 2343 },
        { type: 'pants', price: 2343 },
        { type: 'socks', price: 542 },
        { type: 'pants', price: 123 },
      ];
    */

    /*
      here we find out how many pants or shirts there are (really common in JS)
      and what is the total price 
    */

    const inventoryReducer = (totall, item) => {
      console.log(`loop over ${item.type}`);
      // find out how many items per category we have
      // so first we need to check if the item exist in the object that we start with
      if (totall[item.type]) {
        totall[item.type] += 1;
      } else {
        totall[item.type] = 1;
      }
      return totall;
      // you can also do it in one line
      // totall[item.type] = totall[item.type] + 1 || 1;
    };

    const inventoryCounts = inventory.reduce(inventoryReducer, {});
    /* 
        instead of the empty array we could pass:
        { 
          type: 'shirt', price: 0,
          type: 'pants', price: 0,
          type: 'socks', price: 0
        }
        but does make much sense because sometimes we have to much data to add
        so we add an empty array
    */
    console.log(inventoryCounts);
    const totalInventoryPrice = inventory.reduce(
      (acc, item) => acc + item.price,
      0
    );
    // it returns for each item, the item plus the previous one starting from 0. the total
    console.log(totalInventoryPrice);
 </script>
</body>

</html>


