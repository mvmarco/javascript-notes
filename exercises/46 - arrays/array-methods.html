<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>

  </title>
  <link rel="stylesheet" href="../../base.css">
</head>

<body>
  <script>
    // check https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array

    /* 
      
      there are different types of methods: 

        1: static methods -> Static methods are the methods in JS that can be called 
        without creating an object of class. not available on every single array as the instance methods
        2: instance or prototype methods (because are on the prototype) -> Instance method are methods
        which require an object of its class to be created before it can be called 
        (aka the array you created).
        They can be used on top of any array you created, when you create one 
        you get also the array prototype with its method to be used

    */

    const toppings = [
  'Mushrooms ',
  'Tomatoes',
  'Eggs',
  'Chili',
  'Lettuce',
  'Avocado',
  'Chiles',
  'Bacon',
  'Pickles',
  'Onions',
  'Cheese',
];

    const buns = ['egg', 'wonder', 'brioche'];

    const meats = {
      beyond: 10,
      beef: 5,
      pork: 7,
    };

    const prices = {
      hotDog: 453,
      burger: 765,
      sausage: 634,
      corn: 234,
    };

    const orderTotals = [342, 1002, 523, 34, 634, 854, 1644, 2222];

    const feedback = [
      { comment: 'Love the burgs', rating: 4 },
      { comment: 'Horrible Service', rating: 2 },
      { comment: 'Smoothies are great, liked the burger too', rating: 5 },
      { comment: 'Ambiance needs work', rating: 3 },
      { comment: 'I DONT LIKE BURGERS', rating: 1 },
    ];

    // ############################
    // STATIC METHODS
    // ############################

// -------------------------------------------------------------------------------------------------
    // Array.of();
// -------------------------------------------------------------------------------------------------
    /* 
      not really common. You use it to create an array. for instance

      Array.of('wes, 'marco')  you get  ['wes', 'marco']  I mean you could just do it manually
      but in some cases can be useful. You can also use it to do:
      Array.of(...'wes') getting ['w', 'e', 's'] which it does the same thing
    */
// -------------------------------------------------------------------------------------------------
    // Make a function that creates a range from x to y with:
    // Array.from();
// -------------------------------------------------------------------------------------------------
    /* 
      Array.from({length: 10}) takes something that has a length and return an empty array 
      with that length. Handy if you want an array of 10 or 15 eg items and loop over

      you gotta add the function there too
    */

    const range = Array.from({ length: 10 }, function () {
      return 'marco';
    });

    console.log(range); // you can an array with 10 times 'marco'

    const rangeTwo = Array.from({ length: 10 }, function (item, index) {
      return index; // the value is undefined because the array it is empty
    });

    console.log(rangeTwo); // you get an array with indexes from 0 to 9
    /* 
      if you put _item it will not work, but it is a way to show what is doing 
      even if you dont put any arguments: implicitily will take the item
     */

    // following the exercise with the method:
    
    const createRange = (start, end) => {
      const ranges = Array.from(
        { length: end - start + 1 },
        function (item, index) {
          return index + start;
        }
  );
      return ranges;
    };

    const myRange = createRange(1, 10);
    console.log(myRange);
// -------------------------------------------------------------------------------------------------
    // Check if the last array you created is really an array with:
    // Array.isArray();
// -------------------------------------------------------------------------------------------------
    
    console.log(Array.isArray(myRange)); // should return true (or false in other cases) - in the console
    /*  
    typeof nameOfTheArray in the console will give as result in the console 'object' because
    it holds data and it is not a type. if you wanna check if an array is really an array
    you can do Array.isArray(names);
    */

// -------------------------------------------------------------------------------------------------
    // Take the meats object and make three arrays with Object.entries(), Object.keys, Object.values()
// -------------------------------------------------------------------------------------------------

    // Object.entries(), turns an object into an array, keys, values or both

    console.log(Object.entries(meats)); // here you get an array with 3 nested arrays containing
    // each item and corresponding keys and values
    console.log(Object.keys(meats)); // here you get the keys into one array
    console.log(Object.values(meats)); // here you get the values into one array

    // a common way to use these guys is to loop them over:

    Object.values(meats).forEach((valuesQuantities) => {
      console.log('meat quantities value:');
      console.log(valuesQuantities);
    });

    // you can do the same with the keys

    Object.keys(meats).forEach((keysTypeOfMeat) => {
      console.log('meat type key:');
      console.log(keysTypeOfMeat);
    });

    Object.entries(meats).forEach((entryArray) => {
      console.log('meat entry array:');
      console.log(entryArray);
      console.log('here you just take key and value not in an array');
      const key = entryArray[0];
      const value = entryArray[1];
      /* 
        to male these above two line in one (destructuring)
        you do: const [key, value] = entry 
        where it takes the first item and put into the key const and the second item to the second
        const value.

        a step further would be to, maybe the easiest: 

        Object.entries(meats).forEach((key, value) => {
          console.log(key, value);
        };
      
      */
      console.log(key, value);
    });

    // ############################
    // INSTANCE METHODS
    // ############################

    // methods that lives inside each array

// -------------------------------------------------------------------------------------------------
    // Display all bun types with " or " - use join()
// -------------------------------------------------------------------------------------------------

    console.log(buns.join()); // turns the array into a string
    console.log(buns.join(' or ')); // this will divide each item of the array with or
    // and put it together into a string
// -------------------------------------------------------------------------------------------------
    // We have a string "hot dogs,hamburgers,sausages,corn" - use split() to turn it into an array
// -------------------------------------------------------------------------------------------------

    const string = 'hot dogs,hamburgers,sausages,corn';
    console.log(string.split(',')); // if you dont put the comma, it will split every letter

// -------------------------------------------------------------------------------------------------
    // take the last item off toppings with pop() - REMOVE ITEMS AT THE END
// -------------------------------------------------------------------------------------------------

/* 
  const toppings = [
  'Mushrooms ',
  'Tomatoes',
  'Eggs',
  'Chili',
  'Lettuce',
  'Avocado',
  'Chiles',
  'Bacon',
  'Pickles',
  'Onions',
  'Cheese',
];
*/
    console.log(toppings); // 11 items
    console.log(toppings.pop()); // it removes cheese. the last item
    console.log(toppings); // now 10 items
    // IT IS A MUTABLE METHODS

// -------------------------------------------------------------------------------------------------
    // add it back with push() - PUT ITEMS AT THE END
// -------------------------------------------------------------------------------------------------

    console.log(toppings.push('Cheese')); // you get 11 because when you push a new item to an array
    // you get the new length of the array, if you need it. quite useless
    console.log(toppings);

// -------------------------------------------------------------------------------------------------
    // take the first item off toppings with shift() - REMOVE ITEMS AT THE BEGINNING
// -------------------------------------------------------------------------------------------------

    console.log(toppings); // 11 items
    console.log(toppings.shift()); // you get mushrooms. the first item
    console.log(toppings); // 10 items
    // IT IS A MUTABLE METHOD

// -------------------------------------------------------------------------------------------------
    // add it back in with unshift() - PUT ITEMS AT THE BEGINNING
// -------------------------------------------------------------------------------------------------
    console.log(toppings); // 10 items
    console.log(toppings.unshift('Mushrooms')); // you get 11 the length of the array
    console.log(toppings); // 11 items
// -------------------------------------------------------------------------------------------------
    // take the last four exercises ,with an immutable method (with spreads and new variables)
// -------------------------------------------------------------------------------------------------

    // here you remove the last items from toppings while creating a new array
    let newToppings = [...toppings.slice(0, toppings.length - 1)];
    console.log(newToppings);
    // here you add the last items from toppings back to the newToppings array
    newToppings = [...newToppings, toppings[toppings.length - 1]];
    console.log(newToppings);
    // here you remove the first item from toppings while creating a new array
    console.log(toppings); // original array
    let newToppingsTwo = [...toppings.slice(1)];
    console.log(newToppingsTwo); // remove mushrooms
    newToppingsTwo = [toppings[0], ...newToppingsTwo]; // put it back
    console.log(newToppingsTwo);
// -------------------------------------------------------------------------------------------------
    // Make a copy of the toppings array with slice()
// -------------------------------------------------------------------------------------------------
    console.log(toppings);
    const toppingsSlice = toppings.slice(0);
    console.log(toppingsSlice);

// -------------------------------------------------------------------------------------------------
    // Make a copy of the toppings array with a spread
// -------------------------------------------------------------------------------------------------
    const copyToppings = [...toppings];
    console.log(copyToppings);
// -------------------------------------------------------------------------------------------------
    // take out items 3 to 5 of your new toppings array with splice()
// -------------------------------------------------------------------------------------------------
    const newArraySpliced = [...toppings.splice(0, 2), ...toppings.splice(3)];
    console.log(newArraySpliced);
// -------------------------------------------------------------------------------------------------
    // find the index of Avocado with indexOf() / lastIndexOf()
// -------------------------------------------------------------------------------------------------
    const toppingsNewVersion = [
      'Mushrooms ',
      'Tomatoes',
      'Eggs',
      'Chili',
      'Lettuce',
      'Avocado',
      'Chiles',
      'Bacon',
      'Pickles',
      'Onions',
      'Cheese',
    ];

    console.log(toppingsNewVersion);
    const avoIndex = toppingsNewVersion.indexOf('Avocado');
    console.log(avoIndex); // you get 5
    // if there are multiple avocado you get the first index that matches
    // if you wanna get the last you use lastIndexOf()
    console.log(toppingsNewVersion);
    const avoIndexTwo = toppingsNewVersion.lastIndexOf('Avocado');
    console.log(avoIndexTwo); // still 5 because there is only one avocado

    /* 
      in case we have:
      const wes = {name: 'wes'};
      const people = [{name: 'scott'}, wes];
      if you do:
      people.indexOf(wes) you get 1
      but if you do: people.indexOf({name: 'scott'}) you get -1 because
      as same as: {name: 'wes'} === wes is FALSE, it is not the same thing.
      if you have: const wes2 = {name: 'wes'};
      it is like saying wes2 === wes they are the same but not the same variable.
      so to find out the name of scott or an object you do:
    */

const wes = { name: 'wes' };
const people = [{ name: 'scott' }, { name: 'jhon' }, wes];
console.log(people);

const indexOfScott = people.findIndex((person) => person.name === 'jhon');
console.log(indexOfScott);

// -------------------------------------------------------------------------------------------------
    // Check if hot sauce is in the toppings with includes()
// -------------------------------------------------------------------------------------------------

const isInToppings = toppingsNewVersion.includes('Hot Sauce'); // it is not case sensitive
// you gotta be precise with includes or conver all the array lower case and then what you push in

console.log(isInToppings); // you get false it is not present

// -------------------------------------------------------------------------------------------------
    // add it if it's not
// -------------------------------------------------------------------------------------------------

toppingsNewVersion.push('Hot sauce');
console.log(toppingsNewVersion);

// or you can do:

if (!isInToppings) {
  toppingsNewVersion.push('Hot Sauce');
}
console.log(toppingsNewVersion);

// -------------------------------------------------------------------------------------------------
    // flip those toppings around with reverse() - MUTATABLE METHOD
// -------------------------------------------------------------------------------------------------

const flippedToppings = toppingsNewVersion.reverse();
console.log(flippedToppings);

// -------------------------------------------------------------------------------------------------
    // flip those toppings around with spread and reverse() - IMMUTATABLE METHOD
// -------------------------------------------------------------------------------------------------

const flippedToppingsImmutable = [...toppingsNewVersion.reverse()];
console.log(flippedToppingsImmutable);

    // ############################
    // CALLBACK METHODS
    // ############################

// called like that because most of the times they take as argument a callback function
// check here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array

// -------------------------------------------------------------------------------------------------
    // find the first rating that talks about a burger with find()
// -------------------------------------------------------------------------------------------------

/*  from here:
    const feedback = [
      { comment: 'Love the burgs', rating: 4 },
      { comment: 'Horrible Service', rating: 2 },
      { comment: 'Smoothies are great, liked the burger too', rating: 5 },
      { comment: 'Ambiance needs work', rating: 3 },
      { comment: 'I DONT LIKE BURGERS', rating: 1 },
    ];
  */

// the argument of find takes a callback function that return true or false

const found = feedback.find((element) => element.comment.includes('burgs'));
console.log(found);

// this is a function that can be put in above, takes also optional arguments: index and array
// this function can be used in multiple arrays.

/*
  const findBurgerRating = (eachElement, index, array) => {
    if (eachElement.comment.includes('burg')) {
          return true; // only the value that matches
    }
    return false;
  }; 
*/

// to make it shorter since includes already return true
const findBurgerRating = (eachElement) => eachElement.comment.includes('burg');

const foundTwo = feedback.find(findBurgerRating);
console.log(foundTwo);

/* 
  you can also put a function inside an object that makes it a method
  in a way you can just pass method.find() and get the burger rating like below:

  const util = {
    findRating: (eachFeedback) => {
      return eachFeedback.comment.includes('burg');
    }
  }

  const burgRating = feedback.map(util.findBurgRating);
  or
  const burgRating = feedback.find(util.findBurgRating);

  util is an object you made that contains a method named findRating -
  you could use it to keep multiple utility functions on an object.
  It would likely be better to create them as separate functions 
  and import them individually from a separate JavaScript file.

*/

// if you wanna make another function to search for another word: eg. smoothie
// you gotta duplicate findBurgerRating = (eachElement) => eachElement.comment.includes('burg');

const findSmoothieRating = (eachElement) =>
  eachElement.comment.includes('Smoothie');

// as well as const foundTwo = feedback.find(findBurgerRating);
const foundThree = feedback.find(findSmoothieRating);
console.log(foundThree);

// but it is weird to create functions for every single word so alternatively

/* WITH ARROW FUNCTIONS:

const findWord = (word) => {
  return (singleFeedbackOk) => {
    return singleFeedbackOk.comment.includes(word)
  }
} 

FORMATTED: 
const findWord = (word) => (singleFeedbackOk) =>
singleFeedbackOk.comment.includes(word);


BETTER WITH FUNCTIONS:
*/

function findWord(word) {
  return function (singleFeedbackOk) {
        return singleFeedbackOk.comment.includes(word);
  };
}

const smoothie = feedback.find(findWord('Smoothies'));
console.log(smoothie);
const burg = feedback.find(findWord('burg'));
console.log(burg);

// -------------------------------------------------------------------------------------------------
    // find all ratings that are above 2 with filter()
// -------------------------------------------------------------------------------------------------
    // it will return a new array
    const handleFindAboveTwo = (eachElement) => eachElement.rating > 2;
    const findAboveTwo = feedback.filter(handleFindAboveTwo);
    console.table(findAboveTwo);

    // to make a general one we can always use:
    const handleFindAbove2 = (minRating) => (rate) => rate.rating > minRating;
    // min rating is what the user put
    // rate is a new function that takes each element of the array
    // since each element is an object you do rate.rating where rating is the key
    const findAbove2 = feedback.filter(handleFindAbove2(3));
    console.table(findAbove2);
    
// -------------------------------------------------------------------------------------------------
    // find all ratings that talk about a burger with filter()
// -------------------------------------------------------------------------------------------------

    /* 
      const feedback = [
      { comment: 'Love the burgs', rating: 4 },
      { comment: 'Horrible Service', rating: 2 },
      { comment: 'Smoothies are great, liked the burger too', rating: 5 },
      { comment: 'Ambiance needs work', rating: 3 },
      { comment: 'I DONT LIKE BURGERS', rating: 1 },
      ];
    */

    const handleRatingsBurger = (word) => (item) => item.comment.includes(word);

    const findBurgerComment = feedback.filter(handleRatingsBurger('burg'));
    console.log(findBurgerComment);

    // we can also do it like this:
    function singleFeedback(comment) {
      return comment.comment.includes('burg');
    }
    const burgRatings = feedback.filter(singleFeedback);
    console.table(burgRatings);

    // or like this where di argumnent of the an arrow function is feedback
    const findingCommentBurger = feedback.filter((eachfeedbackItem) =>
      eachfeedbackItem.comment.includes('burg')
    );
    console.log(findingCommentBurger);

    // we can also reuse the find word function
    const findingCommentBurgerTwo = feedback.filter(findWord('burg'));
    console.log(findingCommentBurgerTwo);
// -------------------------------------------------------------------------------------------------
    // Remove the one star rating however you like!
// -------------------------------------------------------------------------------------------------
    /*
        const feedback = [
        { comment: 'Love the burgs', rating: 4 },
        { comment: 'Horrible Service', rating: 2 },
        { comment: 'Smoothies are great, liked the burger too', rating: 5 },
        { comment: 'Ambiance needs work', rating: 3 },
        { comment: 'I DONT LIKE BURGERS', rating: 1 },
        ];
      */

    /* 
        There are different methods and techniques you can use to remove elements from JavaScript arrays:
        pop - Removes from the End of an Array
        shift - Removes from the beginning of an Array
        splice - removes from a specific Array index
        filter - allows you to programatically remove elements from an Array
    */

    // const removeLowRating = feedback.splice(0, 4);
    // console.log(removeLowRating);

    // removing the rating that is equal to 1
    const removeFunction = (item) => item.rating !== 1;
    const removeOneRating = feedback.filter(removeFunction);
    console.table(removeOneRating);
// -------------------------------------------------------------------------------------------------
    // check if there is at least 5 of one type of meat with some()
// -------------------------------------------------------------------------------------------------
    /* 
      const meats = {
        beyond: 10,
        beef: 5,
        pork: 7,
      };
    */
    // first conver the object into array, as some() is an array method
    const meatArray = Object.values(meats);
    console.log(meatArray);
    const checkQuantities = meatArray.some((meatValue) => meatValue >= 5);
    console.log(checkQuantities);

// -------------------------------------------------------------------------------------------------
    // make sure we have at least 3 of every meat with every()
// -------------------------------------------------------------------------------------------------
// 21:00
// -------------------------------------------------------------------------------------------------
    // sort the toppings alphabetically with sort()
// -------------------------------------------------------------------------------------------------

// -------------------------------------------------------------------------------------------------
    // sort the order totals from most expensive to least with .sort()
// -------------------------------------------------------------------------------------------------

// -------------------------------------------------------------------------------------------------
    // Sort the prices with sort()
// -------------------------------------------------------------------------------------------------

    // ############################
    // LOOPING METHODS
    // ############################
  </script>
</body>

</html>


