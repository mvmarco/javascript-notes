<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>For Loops</title>
  <link rel="stylesheet" href="../../base.css">
</head>

<body>
  <script>
    const numbers = [2, 34, 3, 23, 42, 3, 1, 65, 364, 5, 645, 6];

    const name = 'Wes Bos';

    // ###############
    // FOR
    // ###############

    /* 
      it requires 3 things:
      1 an initial expression: where the loops starts
      2 a condition: runs each time before each loops run
        if the condition is true the loops run until it's false,
        when it's false it stops runnung
      3 an increment expression: it increments the initial expression
    */
    // eslint-disable-next-line no-plusplus
    console.log('example 1');
    // eslint-disable-next-line no-plusplus,no-shadow
    for (let i = 0; i <= 10; i++) {
      // we use let because you cannot increment a const
      console.log(i); // you get numbers from 1 to 10
    }

    // you can also increment by different numbers
    console.log('example 2');
    // eslint-disable-next-line no-shadow
    for (let i = 100; i <= 120; i += 2) {
      console.log(i); // you get numbers from 100 to 120 with an increment of 2
    }

    // the old way would be to use array.length
    console.log('example 3');
    // eslint-disable-next-line no-plusplus,no-shadow
    for (let i = 0; i < numbers.length; i++) {
      console.log(i); // you get numbers from 1 to 11 because there are 12 numbers
      // if you want the individual numbers
      console.log(numbers[i]);
    }

    // much easier with a forEach

    // ###############
    // FOR OF
    // ###############

    /* 
      it is relatively new and it is used to loop over iterable (something that has
      a length, a number or a string)
    */

    // const name = 'Wes Bos';

    for (const letter of name) {
      console.log(letter); // it will give us the letter of the name
    }

    /*
      it is better than a forEach because it takes in emoji and it is also shorter:
    */

    const names = ['marco😇', 'lapo🐕'];

    for (const letter of names) {
      console.log(letter); // it print each single element for the array (including emoji not squares)
    }

    // eslint-disable-next-line no-unused-vars
    const namesSplitted = names.forEach((element) => {
      console.log(element.split('')); // here you take the element and split it (letters)
      // since it is a forEach the emoticons are squared
    });

    console.log([...names]); // this will give us emoji

    /* 
      another use case of for of loop is using promises: we did not cover it yet but if
      you need to sequence a bunch of data. Meaning you have to do one thing after another
      in a loop the for of loop will allow us to use the 'await' inside of it. We will learn
      with promises. Just remember: the For of is handy for sequences in promises

      the for of loop can also be used with an array:
    */
    
    for (const number of numbers) {
      console.log(number);
    }

    /* 
      the dowside of using for of is that you get the values of the array and not the index
      or does not allow us to filter
    */
    // ###############
    // FOR IN
    // ###############

    /* 
      for in works similar to for of but it gives us the key of an object.
      in other words is used to loop over keys of an object
      for (const number in numbers) {
        console.log(number); // you get numbers from 0 to 11 because there are 12 numbers (keys)
      }
    */
    
    // another example

    /* 
      const wes = {
        name: 'wes',
        age: 100,
        cool: true,
      };

    for (const propertyKey in wes) {
      console.log(propertyKey); // it will give us the keys: name, age and cool      
    } 

      object.keys or object.entries is the better alternative and because for in is not much used
      but there is an exception between the for in vs the object.entries that makes the for in 
      different, with a thing called prototype:
    */

    const baseHumanStats = {
      feet: 2,
      arms: 2,
      eyes: 2,
      head: 1,
    };

    function Human(namee) {
      this.name = namee;
    }
    Human.prototype = baseHumanStats; // has to be be here before the comment the order matter
    // if you put it later like in the comment you get only the initial object keys
    const wes2 = new Human('wes');
    console.log(wes2); // it is an object of key 'name' and value 'wes'
    // if you do wes.arms is offcourse undefined

    // Human.prototype = baseHumanStats; // doing that wes is still the same but somehow........
    // .......inerith or reference the property of baseHumanStats so if you do wes.arms you get 2
    console.log(wes2);
    /* 
      what happens is that wes2 is referencing the values from the prototype. What happens
      with the prototype is that when you try to access a property first check on the 
      object itself for the property on that and if it is not on there it will look up
      on the prototype chain object.

      if you console.log(wes2); you can see in the console other than the key value set
      __proto__: Object, opening that you see the other properties chained up 

      the exception I was talking about between for in and Object.entries is:

    */

    console.log(Object.entries(wes2)); // you get only name (key) and wes(value)

    /* 
      but if you gonna use for in:

      for (const prop in wes2) {
        console.log(prop); // you get name, feet, arms, eyes, and head as keys
      }
    */

    // ###############################################################
    // WHILE - not so common but there are situation were it is useful
    // ###############################################################

    /* 
      while will take a conditition and run it infinitely until that condition
      is not true anymore
    */
    
    let cool = true;
    let i = 1; // this is a variable to let the while loop stop when it is false
    while (cool === true) {
      console.log('You are cool');
      // eslint-disable-next-line no-plusplus
      i++;
      if (i > 100) {
        cool = false;
      }
    }
    // ##################################################################
    // DO WHILE - not so common but there are situation were it is useful
    // ##################################################################

    /* 
      the only difference between a while loop and a do while loop is that
      there is a do {} while() - do will run first and then check the condition
      (the while one) after the first run.

      the while loop check the confition before the first run and then do it
    */
  </script>
</body>

</html>


<!-- 13,04 -->