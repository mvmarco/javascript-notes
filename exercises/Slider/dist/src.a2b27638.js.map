{"version":3,"sources":["src/index.js"],"names":["Slider","slider","Element","Error","prev","current","next","slides","querySelector","prevButton","nextButton","startSlider","firstElementChild","previousElementSibling","lastElementChild","nextElementSibling","console","log","applyClasses","classList","add","move","direction","classesToRemove","remove","addEventListener","mySlider","document","dogSlider"],"mappings":"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","file":"src.a2b27638.js","sourceRoot":"..","sourcesContent":["/* \n  a slider is basically a class adder/remover through each slide in the html\n  we put this file in src because we have multiple JS, and it is common way to do it\n*/\n\n// the slider refers to the div/elementwith the class of slider\nfunction Slider(slider) {\n  // here you say if the slider is not an element throw an error\n  /* \n    instead of just passing if(!slider) {\n      throw new Error('No slider passed in');\n    }\n\n    in this case if you pass slider('jsjss') it would not be an error\n    because you pass a function with something in, no matter if it is not an element\n  */\n  if (!(slider instanceof Element)) {\n    throw new Error('No slider passed in');\n  }\n  // create some variables for working with the slider\n  /* \n    we need to keep track for prev, current and next to begin with\n    and they have to be empty because we will fill them up when the \n    slider starts, and when the user navigates with previous and next\n    button.\n\n    prev, current and next are basically the SCSS classes associated to\n    the slide. We keep them here at the beginning\n  */\n  let prev;\n  let current;\n  let next;\n\n  // select the elements needed for the slider\n  const slides = slider.querySelector('.slides');\n  const prevButton = slider.querySelector('.goToPrev');\n  const nextButton = slider.querySelector('.goToNext');\n\n  function startSlider() {\n    /*\n      here we update/popilate the variables \"prev\", \"current\" and \"next\"\n      and we update within the function and not create a const inside\n      this startSlider with current, is because we have other functions\n      such as move(), applyClasses() and both of those functions\n      need to access the \"current\", \"prev\" and \"next\".\n\n      So if instead you create a const \"prev\" or \"current\" or \"next\"\n      that const would be accessible only inside this function. By creating\n      them inside the slider funtion all the other function inside can access\n      them.\n\n      That is the concept of \"closures\" having variables at higher level that \n      can be accessed at the lower level. They are not global variables but\n      are variables that are living inside the closure slider function \n    */\n\n    /* \n      1 you take slider because it is the argument of the slider function\n      which is the instance with the slider div. (bottom of the page \n      const mySlider = Slider(document.querySelector('.slider'));) \n      from there you take the class .current which is applied to have an automatic start for the first\n      slider or the firstElementChild of slides (const slides = slider.querySelector('.slides'))  \n      which is in the mother function. Why? because the second div. does not have a current class\n      so you gotta take the first element child of the div.class\n\n      2 for \"prev\" you take the same element before it, or the last for the second slider\n      because before the 1st there is the last. \n\n      3 with next same logic but inverted\n\n      HOW TO TEST IT: CONSOLE>SELECT WITH THE ARROW ONE OF THE SLIDE NUMBER> OPEN CONSOLE AND \n      TYPE $0.previousElementSibling\n\n    */\n    current = slider.querySelector('.current') || slides.firstElementChild;\n    prev = current.previousElementSibling || slides.lastElementChild;\n    next = current.nextElementSibling || slides.firstElementChild;\n    console.log({ current, prev, next });\n  }\n\n  function applyClasses() {\n    current.classList.add('current');\n    prev.classList.add('prev');\n    next.classList.add('next');\n  }\n\n  function move(direction) {\n    // first strip all the classes off the current slides\n    const classesToRemove = ['prev', 'current', 'next'];\n    prev.classList.remove(...classesToRemove);\n    current.classList.remove(...classesToRemove);\n    next.classList.remove(...classesToRemove);\n    if (direction === 'back') {\n      // make an new array of the new values, and destructure them over and into the prev, current and next variables\n      [prev, current, next] = [\n        // get the prev slide, if there is none, get the last slide from the entire slider for wrapping\n        prev.previousElementSibling || slides.lastElementChild,\n        prev,\n        current,\n      ];\n    } else {\n      [prev, current, next] = [\n        current,\n        next,\n        // get the next slide, or if it's at the end, loop around and grab the first slide\n        next.nextElementSibling || slides.firstElementChild,\n      ];\n    }\n\n    applyClasses();\n  }\n\n  // when this slider is created, run the start slider function\n  startSlider();\n  applyClasses();\n\n  // Event listeners\n  prevButton.addEventListener('click', () => move('back'));\n  nextButton.addEventListener('click', move);\n}\n\n// eslint-disable-next-line no-unused-vars\nconst mySlider = Slider(document.querySelector('.slider'));\n// eslint-disable-next-line no-unused-vars\nconst dogSlider = Slider(document.querySelector('.dog-slider'));\n"]}